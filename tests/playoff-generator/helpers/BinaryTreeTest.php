<?php

/**
 * Test class for BinaryTree.
 * Generated by PHPUnit on 2012-02-01 at 12:18:09.
 * @group playoff
 */
class BinaryTreeTest extends PHPUnit_Framework_TestCase {

    /** @var BinaryTree */
    protected $btree;

    /** @var PlayoffDuelParticipant */
    protected $item;

    protected function setUp() {
        $this->btree = new BinaryTree();
        $this->item = new PlayoffDuelParticipant(1, 'item');
    }

    public function testGet_item_count_AND_Destroy() {
        $this->assert_item_count_of_tree(0);
        $this->btree->insert_root($this->item);
        $this->assert_item_count_of_tree(1);
        $this->btree->insert_left_son($this->item);
        $this->btree->insert_right_son($this->item);
        $this->assert_item_count_of_tree(3);        
        $this->btree->destroy();
        $this->assert_item_count_of_tree(0);
    }

    public function testInsert_root() {
        $this->btree->insert_root($this->item);
        $this->assert_item_count_of_tree(1);
        $this->btree->insert_root($this->item);
        $this->assert_item_count_of_tree(1); // root is inserted only to empty tree
        
        $this->btree->destroy();
        $this->test_bad_item('insert_root');
    }

    public function testInsert_left_son() {
        $this->btree->insert_left_son($this->item);
        $this->assert_item_count_of_tree(0);
        
        $this->btree->insert_root($this->item);                
        $this->test_bad_item('insert_left_son');
        $this->btree->insert_left_son($this->item);
        $this->assert_item_count_of_tree(2);
        $this->btree->insert_left_son($this->item);
        $this->assert_item_count_of_tree(2);   
    }

    public function testInsert_right_son() {        
        $this->btree->insert_right_son($this->item);
        $this->assert_item_count_of_tree(0);
        
        $this->btree->insert_root($this->item);                
        $this->test_bad_item('insert_right_son');
        $this->btree->insert_right_son($this->item);
        $this->assert_item_count_of_tree(2);
        $this->btree->insert_right_son($this->item);
        $this->assert_item_count_of_tree(2);      
    }

    public function testDelete_left_son() {
        parent::assertNull($this->btree->delete_left_son());
        $this->btree->insert_root($this->item);
        $this->btree->insert_left_son($this->item);
        $this->assert_item($this->btree->delete_left_son());        
        parent::assertNull($this->btree->delete_left_son());
    }

    public function testDelete_right_son() {
        parent::assertNull($this->btree->delete_right_son());
        $this->btree->insert_root($this->item);
        $this->btree->insert_right_son($this->item);
        $this->assert_item($this->btree->delete_right_son());        
        parent::assertNull($this->btree->delete_right_son());
    }

    public function testAccess_root() {
        parent::assertNull($this->btree->access_root());
        $this->btree->insert_root($this->item);
        $this->assert_item($this->btree->access_root());
    }

    public function testAccess_left_son() {
        parent::assertNull($this->btree->access_left_son());
        $this->btree->insert_root($this->item);
        $this->btree->insert_left_son($this->item);
        $this->assert_item($this->btree->access_left_son());
        // actual position = left son of the root
        parent::assertNull($this->btree->access_left_son());
    }

    public function testAccess_right_son() {
        parent::assertNull($this->btree->access_right_son());
        $this->btree->insert_root($this->item);
        $this->btree->insert_right_son($this->item);
        $this->assert_item($this->btree->access_right_son());
        // actual position = right son of the root
        parent::assertNull($this->btree->access_right_son());
    }

    public function testAccess_first() {
        parent::assertNull($this->btree->access_first($this->item));
        $this->btree->insert_root($this->item);
        $this->assert_item($this->btree->access_first($this->item));
        parent::assertNull($this->btree->access_first(new PlayoffDuelParticipant(2, 2)));
    }

    public function testGet_items() {
        $this->btree->insert_root($this->item);
        $this->btree->insert_left_son($this->item);
        $this->btree->insert_right_son($this->item);
        
        $items = $this->btree->get_items();
        parent::assertEquals($this->btree->get_item_count(), count($items));
        foreach ($items as $item) {
            parent::assertInstanceOf('IBTreeItem', $item);
        }
    }
    
    // $item must implements IBTreeItem
    private function test_bad_item($method_name) {
        $invalid_values = array(0, 'a', null, false, array(), new Exception());
        foreach ($invalid_values as $value) {
            try {
                $this->btree->$method_name($value);
                parent::fail('This test did not fail as expected');
            } catch (PlayoffException $e) {
                parent::assertEquals($e->getCode(), PlayoffException::EXC6);
            }            
        }
    }
    
    private function assert_item($item) {
        parent::assertInstanceOf('IBTreeItem', $item);
        parent::assertEquals($item, $this->item);
    }

    private function assert_item_count_of_tree($expected) {
        parent::assertEquals($this->btree->get_item_count(), $expected);
    }

}

?>
